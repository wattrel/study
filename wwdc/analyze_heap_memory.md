Analyze heap memory

Focus: Heap
detect and diagnose memory issue - wwdc21 
iOS memory deep dive - wwdc18


힙 메모리란 무엇인가?
참조 타입이 저장되는 공간

앱의 가상 메모리
앱이 시작될 때 각자 비어있는 주소 공간을 할당 받게 된다.

앱이 실행될 때
앱의 주요 실행 파일 - 초록
링크된 라이브러리 및 프레임 워크 로드 - 보라색

디스크에서 읽기 전용 리소스들을 메모리에 매핑 -  빨간, 파란

실행 중에는 각 스레드의 로컬 변수와 임시 변수를 저장하기 위해 [스택 영역]을 사용
동적이고 장기간 유지되는 메모리는 힙이라는 메모리 영역에 저장합니다.
￼


힙은 단순히 하나의 연속된 메모리 블록이 아니며, 여러 개의 가상 메모리 영역으로 구성
각 영역은 개별적인 힙 할당들로 나뉘며, 운영체제가 16kb 크기의 메모리 페이지 단위로 관리하지만 실제 할당 크기는 가변적일 수 있음.
이러한 메모리 페이지는 크게 세가지 상태로 나뉜다. clean, dirty, swapped(compressed)

clean page
아직 기록되지 않는 메모리
할당되었지만 사용되지 않은 공간이거나, 디스크에서 읽기 전용으로 매핑된 파일을 나타낼 수 있다. 
시스템에서 언제든지 clean page를 삭제할 수 있으며, 다시 접근할 경우 필요한 데이터를 디스크에서 다시 메모리로 로드하면 되기 때문에 비용이 상대적으로 낮음.

dirty page
앱에서 최근에 데이터를 기록한 메모리
한동안 사용되지 않더라도 즉시 삭제할 수 없으며, 메모리 압박이 발생하면 운영체제가 이를 swap할 수 있습니다.
swap 방식
1. 압축(Compressing): 메모리를 압축하여 동일한 물리적 메모리 내에서 더 작은 공간을 차지하도록 만듬
2. 디스크로 저장(Writing to disk): 더 이상 RAM에서 유지할 수 없는 경우, 데이터를 디스크에 저장하고 필요할 때 다시 불러옴

저장된 더티 페이지는 다시 필요할 경우, 해제하거나 디스크로부터 불러오는 방식으로 복구

￼

위 세가지 상태 중  dirty page, swapped page만 메모리 사용량(memory footprint)으로 계산.

힙 영역은 malloc, calloc, realloc과 같은 함수를 통해 생성된 메모리이며, 이런 함수를 직접적으로 호출하지 않지만 컴파일러와 런타임에 광범위하게사용하고 있다.
(클래스 인스턴스를 생성할 때도 내부적으로 malloc이 호출됨)

malloc으로 앱에서 장기 메모리를 동적으로 할당할 수 있다. 할당은 명시적으로 해제될 때까지 유지되며
할당을 생성한 코드의 범위를 넘어설 수 있다.

최소 할당 크기와 정렬은 16바이트이므로, 4바이트를 요청하더라도 16바이트로 올림처리가 됨
보안 기능으로 해제될 때 모두 0이 된다.

Swift 런타임은 힙을 사용하여 장기 메모리를 할당한다.

이런 malloc에는 몇 가지 디버깅 기능이 있는데
그 중 하나가 MallocStackLogging으로, 각 메모리 할당에 대한 콜스택과 타임스탬프를 기록한다.
다시 말해 언제 어디서 메모리가 할당되었는지 추적하기 편함

￼

1. Xcode Memory Report
앱 메모리 사용량은 단순히 힙 메모리만 포함하는 것이 아니라, 다른 여러 메모리 영역도 포함
메모리 보고서를 통해 큰 규모의 메모리 문제와 최근 사용량 변화를 확인할 수 있음

2. Memory Graph Debugger
메모리 그래프를 캡처할 수 있으며, 모든 메모리 할당과 객체간 참조 관계를 스냅샷 형태로 시각화 해줌.
MallocStackLoggin이 활성화 된 경우, 각 메모리 할당에 대한 백트레이스 정보도 포함되기 때문에 어떤 코드에서 메모리 할당되었는디 더 쉽게 추적 가능

메모리 급증은 메모리 압박을 유발합니다.
시스템은 다음과 같은 방식으로 메모리 압박을 완화하려고 합니ㅏㄷ.
- 더티 메모리를 스왑하거나 압축함
- 읽기 전용 메모리 삭제
- 백그라운드 작업을 종료

최악의 경우 이러한 메모리 급증이 앱 종료로 이어질 수 있음.
장기적으로 메모리 급증은 힙 메모리 영역에서 단편화(Fragmentation) 또는 메모리의 구멍을 발생시켜, 메모리 사용 효율성을 저하 시킴.

메모리 급증을 추적하는 두가지 방법
1. 특정 파이크 분석
낮은 지점부터 높은 지점까지의 메모리 할당을 찾아서 어떤 할당이 여전히 유지되고 있는지 확인하는 방법

통계 세부 정보에 어떤 요인이 메모리 급증을 일으켰는지 확인할 수 있음. 총 바이트 기준으로 정렬하여 가장 큰 요소가 누구인지 확인하기
(IOSurface 가상 메모리로 나타날 경우 백그라운드 이미지 처리 방식에 문제가 있을 가능성이 높다는 힌트임.)

persistent 메모리 기준으로 정렬하여, 스파이크에서 최상위로 올라간 객체를 확인하기
예시에서는 autoreleasepool content가 눈에 띔

2. 전체 범위에서 분석
보다 넓은 범위를 선택한 후, 그 범위 내에서 생성되었다가 파괴된 모든 할당을 확인하여 메모리 사용 패턴을 분석
하단의 Lifespan필터를 Created & Destroyed로 변경

detail view에서 call tree로 전환
call tree는 메모리 할당을 백트레이스 별로 분류하여, 어떤 코드가 가장 많은 메모리를 할당하는지 쉽게 볼 수 있음

￼
한줄의 코드에서 기가바이트 단위의 메모리 할당과 해제가 발생
이런 메모리는 임시 메모리여야 하지만 스파이크 꼭대기까지 계속 증가했다가 한번에 해제되는 현상이 나타나고 있음.

썸네일 루프 내에서 페이지 폴트하는 과정에서 메모리가 계속 증가하다가 루프가 종료될 때 한꺼번에 감소하는 현상

Swift는 ARC를 사용하지만,  @autoreleasepool은 임시 메모리 증가의 흔한 원인 중 하나
objective-c 함수 반환값의 객체 생명 주기를 연장하기 위해 사용됨.
이러한 반환값은 즉시 해제하지 않고 일정 시간이 지난 후 해제하도록 만듬. 그러나 swift에서 objective-c api를 호출할 때도 자동 해제 객체가 생성될 수 있음.

```
print(NSDate().description)
```

문자열은 힙 메모리에 남아 있으며, 현재 @autoreleasepool 범위가 끝날떄 까지 유지됨
해제 시점이 늦춰질 수 있으며, 그동안 메모리가 계속 증가할 가능성이 있음.

￼

스레드는 일반적으로 최상위 수준의 @autoreleasepool를 가지지만, “자주 정리되지 않습니다.”
코드가 @autoreleasepool에 많은 객체를 추가하면, 특히 루프에서 이런 문제가 자주 발생함.

각 반복마다 객체가 같은 @autoreleasepool에 자동으로 해제되도록 추가되며, 이로 인해 객체의 수명이 필요 이상으로 길어질 수 있다.
이 경우, 루프가 모두 끝날 때까지 객체가 유지됨.

내부적으로 @autoreleasepool은 객체를 참조하기 위해 컨텐츠 페이지를 할당함
이러한 페이지들은 Allocations 인스트루먼트에서 확인할 수 있기 때문에 이러한 문제를 감지하는 데 유용할 수 있다.
이후 @autoreleasepool이 비워질 때, 지연된 해제가 한꺼번에 실행되며 많은 객체들이 한꺼번에 해제될 수 있다.

이 문제를 해결하는 방법은 로컬 @autoreleasepool 정의해서 수명을 좁히는 것이다.
각 반복이 끝날 때마다 해제가 되도록.
￼

Generation 비교를 통해 동일하게 증가되는 문제에 대해서 진단할 수 있음.
Growth Size기준으로 정렬하면, 어떤 타입이 가장 많은 메모리를 차지하는지 확인할 수 있음.
(예시에서는 Data 타입의 저장 공간에서 발생)

Instruments의 주소 중 하나를 선택하여 Memory Graph Debugger에 참조 관계를 확인할 수 있다.

Memory Graph Debugger을 사용할 때 갖아야할 의문점은
- 이 할당이 왜 아직 존재하는가? 
- 할당에 무엇이 있는가?
그리고 이 도구를 효과적으로 사용하려면 “타입 정보”와 참조 스캔 방식을 이해해야합니다.

참조 유형에는 네가지가 존재
1. strong
ARC에서 소유권이 명확히 보장된 포인터, 객체의 생명 주기를 유지하는 명시적 강한 참조
2. weak/ unowned
명시적 비소유권이 보장되는 확실한 포인터(해당 포인터가 가리키는 객체의 메모리 관리(생성, 해제)를 직접 관리하지 않는 참조)
참조하고 있는 객체가 해제되면 weak는 자동으로 nil이 할당됨, unowned는 nil로 변하지 않기 때문에 접근 시 크래시 발생
3. unmanaged
런타임이 알고 있지만 자동으로 관리하지 않는 포인터입니다. 수동으로 객체를 소유하는 참조일 수도 있지만, 그렇지 않을수도 있다.
4. conservative
도구가 스캔하는 메모리의 정확한 타입을 알지 못할 때 기록되는 참조
단순한 메모리 값이 포인터처럼 보일 수도 있지만, 타입 정보가 없으면 실제 포인터인지 확신할 수 없다.

도구가 프로세스의 힙을 스캔할 때, 각 할당에 대해 사용 가능한 가장 신뢰할 수 있는 타입 정보를 기반으로 분석함.

“3,4 번의 경우 Swift나 objective-c를 사용할 경우 문제가 발생하지 않을 확률이 아주 높음”

# Reachability
￼
프로그램 내의 모든 메모리는 non-weak 참조를 통해 접근 가능해야 하며, 향후 다시 사용될 수 있어야합니다.
힙에서는 세가지 유형의 메모리가 존재
1. Useful memory
프로그램에서 접근할 수 있으며, 앞으로 다시 사용될 예정인 메모리

2. Abandoned memory
접근할 수는 있지만, 실제로 다시 사용되지 않을 메모리 <- 진짜 많이 고려해야할 대상
이러한 메모리는 앱 메모리 사용량을 증가시키며, 낭비되는 메모리
과도한 캐싱, singleton이 많을 경우

3. 누수된 메모리
더 이상 접근할 수 없는 메모리로, 절대 다시 사용될 수 없는 메모리
수동으로 관리된 할당을 잃어버리거나(참조를 해제하지 못한 경우), 객체 간의 순환 참조로 인해 발생


Closure context
클로저는 값을 캡처할 때 힙에 메모리를 할당하여 해당 값을 저장합니다.
Memory Graph Debugger에서 이런 메모리 할당을 closure contexts로 라벨링함
앱의 힙에서 각 클로저 컨텍스트는 활성 클로저와 1:1로 매칭

weak가 속도가 조금 더 느림 unowned에 비해
weak reference storage을 거쳐 확인해야하기 때문

unowned 참조는 대상을 직접 보유하게 됨
추가적인 메모리를 할당하지 않고도 바로 접근이 가능함.

￼

Swift Programming Language chapter on ARC

성능 최적화하기 위해서 arc를 포기하지 말아라
- whole-module-optimization을 활성화 시키기
인라이닝을 더 많이 허용해 오버헤드를 줄일 수 있다. 추가적으로 프로파일링을 통해 성능을 분석하고, 제네릭 코드를 줄이자.
제네릭의 경우 컴파일 타임에 최적화할 수 없음

프로파일링을 통해 비용이 많이 드는 구조체 복사를 식별할 수 있다. 이런 구조체의 경우 CoW타입 그리고 any의 사용을 최소화 하는 것이 좋음. <- 굿

￼

Explore swift performance 궁금




