# Shared State: The Solution, Part 2
일시: 1월 20일 오후 10시

@김성현

Shared 타입을 사용해서 내비게이션 간에 데이터를 사라지지 않게 하기
프로퍼티 래퍼의 projectedValue를 활용하기

테크닉:
내비게이션 전 명령을 수행하기 위해 NavigationLink를 버튼으로 변경
SwiftUI 뷰에 컨텍스트 정보를 포함해서 내비게이션 버튼에 분기를 칠 수 있다.

@홍승현

@윤용운
값타입 장점에 너무 초점을 두고 작업을 하다보니, 참조타입의 편의성을 그동안 너무 가리고 살았음.
하지만 여전히 위험성은 존재해보임. 구체타입을 전달하기 때문에 어느곳에서든 뮤테이션이 가능한점.

@Reducer 매크로 안써봤지만 많은 기능들을 제공해줌. 기존에는 Binding하고 State하고 묶기 위해서 해줘야했던 것들을 자동으로 해줌.
하지만 반대로 TCA 사용법대로 사용하지 못한다면, 혹은 낮은 버전을 사용할 경우 어떻게 접근해야할지 모를 거 같다는 생각이듬.’

그리고 매크로 섹션도 보고싶다는 생각이 계속 듬 배울 것들이 많이 숨어있을 거 같음.

프로퍼티 래퍼를 Container 특성을 갖고 있는 경우 사용하면 좋을 거 같음
타입 자체가 복잡해지면 가독성이 떨어지게 되는데 이런 경우 사용하면 좋아보임.
``` swift
let cache: LockIsolated<NSCache<NSString, Object<T>> 
@LockIsoated let cache: NSCache<NSString, Object<T>>
[성현님: 무조건 프로퍼티 래퍼가 변수여만해서 안됨.] <- 면접 질문으로 좋은 거 같음. 
```
@Bindable의 실제 구현된 코드를 봐보는것도 좋을 거 같음. 

값을 보관하고 처리하는 경우 프로퍼티 래퍼를 잘 사용할 수 있을 거 같음.

관리해야하는 상태값과 뷰모델(정말 뷰를 꾸미는 상태)를 분리해서 관리하는 게 중요해보임. 모든 걸 State에 담으려고 하지 않고 적절하게 분리할 줄 아는게 포인트.

강의에서 다루지 않았지만 시트가 올라왔을 때, 디밍뷰를 누르게 되면 전달받을 수 있는 이벤트를 전달받기 위해서 결국 커스텀뷰가 필요해보임. <- 이걸 어떻게 만들 수 있을까요?
몇줄의 코드로 여러 상황이 잘 핸들링되는것 처럼 보이기 위해서, 뒷단에선 여러가지 작업들을 했을텐데 사실 그 부분을 봐야 더 이해가 될 듯.
SwiftUI.Dismiss하고 Dependency.Dismiss하고 동작은 유사하지만 다름. 하지만 SwiftUI.Dismiss가 발생해도 리듀서 상태값은 변경되고 Dependency.Dismiss되도 뷰는 닫힘.
뷰와 로직을 우리가 모르게 잘 바인딩했을텐데 이런 기술들은 눈여겨보면 배울게 많을 거 같음.


---- 
잡담시간
@Namespace는 뷰의 계층에서의 ID이다. 백단에서 사용하는 id같은 느낌

``` swift
        let task = Task {
          if Task.isCancelled {
            print("Hello?") <- 호출됨.
          }
        }
        
        1, 2번의 경우에서만 호출되긴함.
        1. 
        task.cancel
        
        2.
        Task {
          task.cancel() 
        }
```
        
        결론: 의미가 있을 수 있다.
        
autoresizingMask -> OptionalSet이랑 연관됨. 한번 정리하면 좋겠음.
